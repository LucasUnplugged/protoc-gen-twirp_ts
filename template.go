package main

import (
	"bytes"
	"fmt"
	"log"
	"strings"
	"text/template"
)

type Compilable interface {
	Compile() (string, error)
}

type importValues struct {
	Name string
	Path string
}

const importTemplate = `
{{- if ne .Name "timestamp" -}}
import * as {{.Name}} from './{{.Path}}'
{{end -}}
`

func (iv *importValues) Compile() (string, error) {
	return compileAndExecute(importTemplate, iv)
}

type enumKeyVal struct {
	Name  string
	Value int32
}

type enumValues struct {
	Name   string
	Values []*enumKeyVal
}

const enumTemplate = `
{{- $enumName := .Name}}
export const {{$enumName}} = {
  {{- range $i, $v := .Values}}
  {{- if $i}},{{end}}
  {{$v.Name}}: {{$v.Value}}
  {{- end}}
}
`

func (ev *enumValues) Compile() (string, error) {
	return compileAndExecute(enumTemplate, ev)
}

type serviceValues struct {
	Package   string
	Name      string
	Interface string
	Methods   []*serviceMethodValues
}

var serviceTemplate = `
export interface {{.Interface}} {
  {{- range .Methods}}
  {{.Name}}: (data: {{.InputType}}) => Promise<{{.OutputType}}>
  {{- end}}
}

export class {{.Name}} implements {{.Interface}} {
  private hostname: string
  private fetch: Fetch
  private path = '/twirp/{{.Package}}.{{.Name}}/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = fetch
  }

	private url(name string): string {
		this.hostname + this.path + name
	}

  {{range .Methods}}
  {{.Name}}(params: {{.InputType}}, headers = {}): Promise<{{.OutputType}}> {
    return this.fetch(
			this.url('{{.Name}}'),
			createTwirpRequest(params, headers)
		).then((res) => {
      if (!res.ok) {
        return throwTwirpError(res)
      }
      return res.json().then((m) => { return new {{.OutputType}}(m)})
    })
  }
  {{end}}
}
`

func (sv *serviceValues) Compile() (string, error) {
	return compileAndExecute(serviceTemplate, sv)
}

type serviceMethodValues struct {
	Name string

	Path       string
	InputType  string
	OutputType string
}

type fieldValues struct {
	Name       string
	Field      string
	Type       string
	JSONType   string
	IsRepeated bool
}

type messageValues struct {
	Name      string
	Interface string

	//Type     string
	//JSONType string
	Fields []*fieldValues
}

var messageTemplate = `
export interface {{.Interface}} {
  {{- range .Fields}}
  {{.Field }}?: {{.Type}}
  {{- end}}

	toJSON(): string
}

export class {{.Name}} implements {{.Interface}} {
	{{range .Fields}}
		private _{{.Name}}: {{.Type}}
	{{end}}

	constructor(m: object) {
		if (!m) {return}
		{{- range $i, $v := .Fields}}
		this.{{$v.Field}} = {{ $v | objectToField }}
		{{- end}}
	}

	{{range .Fields}}
		public get {{.Field}}(): {{.Type}} {
			return this._{{.Name}}
		}
		public set {{.Field}}(value: {{.Type}}) {
			this._{{.Name}} = value
		}
	{{end}}

	toJSON(): string {
		return JSON.stringify({
		{{range $i, $v := .Fields}}
			{{- if $i}},{{end}}
			'{{$v.Name}}': this.{{$v.Field}}
		{{- end}}
		})
	}
}
`

func (mv *messageValues) Compile() (string, error) {
	return compileAndExecute(messageTemplate, mv)
}

type protoFile struct {
	Messages []*messageValues
	Services []*serviceValues
	Enums    []*enumValues
	Imports  map[string]*importValues
}

var protoTemplate = `/* tslint:disable */

// This file has been generated by https://github.com/horizon-games/protoc-gen-twirp_ts.
// Do not edit.

{{if .Imports}}
{{- range .Imports}}
{{- . | compile}}
{{- end}}
{{- end}}

{{- if .Services}}
import {
  createTwirpRequest,
  Fetch,
  throwTwirpError
} from './twirp'
{{- end}}

{{- if .Enums}}
// Enums
{{- range .Enums}}
{{- . | compile}}
{{- end}}
{{- end}}

{{- if .Messages}}
// Messages
{{- range .Messages}}
{{- . | compile}}
{{- end}}
{{- end}}

{{- if .Services}}

// Services
{{- range .Services}}
{{- . | compile}}
{{- end}}
{{- end}}
`

func compile(c Compilable) string {
	s, err := c.Compile()
	if err != nil {
		log.Fatal("failed to compile: ", err)
	}
	return s
}

func (pf *protoFile) Compile() (string, error) {
	return compileAndExecute(protoTemplate, pf)
}

func methodName(method string) string {
	return strings.ToLower(method[0:1]) + method[1:]
}

func argumentName(method string) string {
	return "_" + methodName(removePkg(method))
}

func jsonName(name string) string {
	return name
}

func compileAndExecute(tpl string, data interface{}) (string, error) {
	funcMap := template.FuncMap{
		"compile":       compile,
		"objectToField": objectToField,
		//"camelCase":      camelCase,
		//"methodName":     methodName,
		//"jsonName":       jsonName,
		//"fromJSON":       fromJSON,
		//"toJSON":         toJSON,
		//"upperCaseFirst": upperCaseFirst,
		//"jsonToType":     jsonToType,
		//"newType":        newType,
		//"typeToJSON":     typeToJSON,
		//"argumentName":   argumentName,
	}

	t, err := template.New("").Funcs(funcMap).Parse(tpl)
	if err != nil {
		return "", err
	}

	buf := bytes.NewBuffer(nil)
	if err := t.Execute(buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func typeToJSON(s string) string {
	return s + "ToJSON"
}

func newType(typeName string) string {
	typeChunks := strings.SplitN(typeName, ".", 2)
	if len(typeChunks) > 1 {
		return fmt.Sprintf("%s.New%s", typeChunks[0], typeChunks[1])
	}
	return fmt.Sprintf("New%s", typeChunks[0])
}

func jsonToType(typeName string) string {
	typeChunks := strings.SplitN(typeName, ".", 2)
	if len(typeChunks) > 1 {
		return fmt.Sprintf("%s.JSONTo%s", typeChunks[0], typeChunks[1])
	}
	return fmt.Sprintf("JSONTo%s", typeChunks[0])
}

func objectToField(fv fieldValues) string {
	if fv.IsRepeated {
		singularType := fv.Type[0 : len(fv.Type)-2] // Remove []
		switch singularType {
		case "string", "number", "boolean":
			return fmt.Sprintf("(m['%s'] || []).map((v) => { return %s(v)})", fv.Name, upperCaseFirst(singularType))
		}
		return fmt.Sprintf("(m['%s'] || []).map((v) => { return new %s(v)})", fv.Name, upperCaseFirst(singularType))
	}
	switch fv.Type {
	case "string", "number", "boolean":
		return fmt.Sprintf("m['%s']", fv.Name)
	}
	return fmt.Sprintf("new %s(m['%s'])", fv.Type[1:], fv.Name)
}

/*
func fromJSON(f fieldValues) string {
	if f.IsRepeated {
		singularType := f.Type[0 : len(f.Type)-2] // Remove []

		switch singularType {
		case "string", "number", "boolean":
			return fmt.Sprintf("(m.%s || []).map((v) => {return %s(v)})", f.Name, upperCaseFirst(singularType))
		}

		if strings.HasSuffix(singularType, "Model") {
			singularType = singularType[0 : len(singularType)-5]
		}

		return fmt.Sprintf("(m.%s || []).map(%s)", f.Name, jsonToType(singularType))
	}

	if strings.HasSuffix(f.Type, "Model") {
		return fmt.Sprintf("%s(m.%s)", jsonToType(f.Type[0:len(f.Type)-5]), f.Name)
	}

	return "m." + f.Name
}

func toJSON(f fieldValues) string {
	if f.IsRepeated {
		singularType := f.Type[0 : len(f.Type)-2] // Remove []
		switch singularType {
		case "string", "number", "boolean":
			return fmt.Sprintf("(m.%s || []).map((v) => {return %s(v)})", camelCase(f.Name), upperCaseFirst(singularType))
		}
		return fmt.Sprintf("(m.%s || []).map(%sToJSON)", camelCase(f.Name), singularType)
	}
	if strings.HasSuffix(f.Type, "Model") {
		return fmt.Sprintf("%sToJSON(m.%s)", f.Type, camelCase(f.Name))
	}
	return "m." + camelCase(f.Name)
}
*/
